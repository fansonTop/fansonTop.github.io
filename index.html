<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />
        <title>fansonTop</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">fansonTop</a></h1>
                <nav><ul>
                    <li><a href="/category/java.html">Java</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/springxue-xi.html">Spring学习</a></h1>
<footer class="post-info">
        <abbr class="published" title="2021-12-03T10:20:00+01:00">
                Published: 五 03 十二月 2021
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/fanson.html">fanson</a>
        </address>
<p>In <a href="/category/java.html">Java</a>.</p>

</footer><!-- /.post-info --><h3>1.学习经过</h3>
<p>Spring(2) + SpringMVC(3) + MyBatis(2) + AJAX(1) + SpringBoot(1)</p>
<h3>2.Spring框架</h3>
<p>框架（Framework):一系列的jar包，同时约定了实现某个功能的编程方式，可能于原有的编程方式并不相同！每个框架都解决了某些特定的问题！</p>
<p>Spring框架解决的问题：解决了创建和管理对象的问题，实现了解耦！</p>
<p>简单的创建对象的语法大致是
      User user = new User();
使用以上方式创建对象不便于实现解藕！
解藕：接触对象之间的耦合！即降低对象之间的依赖关系！
依赖：在一个对象的工作过程中需要使用到另一个对象，则称之为依赖另一个对象</p>
<p>例如:</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserJdbcDao</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">login</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 连接数据库</span>
    <span class="c1">// 执行SQL语句</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserLoginServlet</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="n">UserJdbcDao</span> <span class="n">userJdbcDao</span> <span class="o">=</span> <span class="k">new</span> <span class="n">UserJdbcDao</span><span class="p">();</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doPost</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">userDao</span><span class="p">.</span><span class="na">login</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>在以上代码中<code>UserLoginServlet</code>就是依赖于<code>UserJdbcDao</code>的！</p>
<p>在以上代码的基础智商，如果<code>UserJdbcDao</code>使用的技术需要更换，或者出于其他的原因，这个类已经不再满足项目的需求，需要换成另一个类，或者使用另一种技术来实现，则可能创建新的<code>UserMyBatisDao</code>来替换原来的<code>UserJdbcDao</code>！</p>
<p>如果需要替换，则以上代码中<code>public UserJdbcDao userJdbcDao = new UserJdbcDao();</code>就需要被替换为：
    public UserMyBatisDao userMyBatisDao = new UserMyBatisDao();</p>
<p>如果这个项目中，有多个<code>Servlet</code>组建都使用了<code>UserJdbcDao</code>，则需要替换多次！</p>
<p>所以，如果要把<code>UserJdbcDao</code>替换为<code>UserMyBatisDao</code>，整个项目中需要调整的代码可能较多！通常，就称之为“耦合度太高”！</p>
<p>首先，可以定义一个接口</p>
<div class="highlight"><pre><span></span><code>public interface UserDao() {
  void login();
}
</code></pre></div>

<p>然后使得<code>UserJdbcDao</code>和<code>UserMyBatisDao</code>都实现以上接口！则后续需要使用DAO对象，可以声明为：</p>
<div class="highlight"><pre><span></span><code>// 使用接口声明，创建某个实现类的对象
public UserDao userDao = new UserMyBatisDao();
</code></pre></div>

<p>则后续需要替换时，该对象的声明语句是不用调整！</p>
<p>接下来，还可以使用设计模式中的工厂模式来解决创建对象的问题：</p>
<div class="highlight"><pre><span></span><code>  public class UserDaoFactory {
    public static UserDaot newInstatnce() {
      reutrn new UserJdbcDao();
    }
  }
</code></pre></div>

<p>则此前的代码可以进一步调整为：
  public UserDao userDao = UserDaoFactory.newInstatnce();</p>
<p>以上代码中根本就没有出现哪个实现类的名称，如果需要替换实现类，以上代码就根本不需要调整！需要调整的只有工厂类中的方法的返回值而已！</p>
<p>也可以看到，在<code>Servlet</code>类中，根本就不需要出现某个DAO类的名称，则可以称之为<strong>UserLoginServlet不依赖UserJdbcDao或UserMyBatisDao</strong>!也就接触了<code>UserLoginServlet</code>和<code>UserJdbcDao</code>或<code>UserMyBatisDao</code>之间的耦合度！</p>
<p>以上做法中，就使用到了接口、工厂类，它们是解藕的核心！但是在实际开发某个项目时，不可能为大量的类都去创建对应的接口与工厂类！所以，就出现了Spring框架！可以简单的将Spring框架理解为一个大型工厂，专门用于创建和管理项目中所需要的类的对象，当需要使用某个对象时，从Spring框架中获取即可，而不再是自行创建对象、自行编写工厂等！</p>
<h3>3.通过无参数构造方法，使用Spring创建对象，并从Spring中获取对象</h3>
<p>首先创建 <strong>Maven Project</strong>， 创建过程中，勾选<strong>Create a simple Poroject</strong>， <strong>Group Id</strong>填写<code>cn.tedu</code>, <strong>Artifact Id</strong>填写<code>Spring01</code>, <strong>Packaging</strong>选择<code>war</code>.</p>
<blockquote>
<p>如果仅仅只是使用Spring，以上<strong>Packaging</strong>并不需要选择<code>war</code>,选择<code>jar</code>也是可以的</p>
</blockquote>
<p>创建的项目默认没有<strong>web.xml</strong>文件，需要先生成该文件，否则，项目会报错！</p>
<p>创建完成后，需要在<strong>pom.xml</strong>中添加<code>org.springframework</code>依赖：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-webmvc<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.3.5<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>

<blockquote>
<p>此次所添加的依赖只要是4.2或以上版本均可！</p>
<p>如果只是使用Spring框架的内容，添加<code>spring-context</code>依赖即可，并不需要<code>spring-webmvc</code>由于后续继续学习SpringMVC框架，在<code>spring-webmvc</code>中包含了<code>Spring-context</code>，所以也可以直接使用<code>spring-webmvc</code></p>
</blockquote>
<p>然后下载<strong>Spring配置文件</strong>，解压后得到applicationcontext.xml，将该文件复制到项目的<strong>src/main/resuorce</strong>下。</p>
<p>假设需要通过Spring创建<code>Date</code>类的对象，则在<strong>applicationContext.xml</strong>中添加配置：</p>
<div class="highlight"><pre><span></span><code><span class="c">&lt;!-- 需要获取Date类的对象 --&gt;</span>
<span class="c">&lt;!-- id属性：名称，后续将根据这个名称获取对象 --&gt;</span>
<span class="c">&lt;!-- class属性：创建哪个类的对象 --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;date&quot;</span> <span class="na">class=</span><span class="s">&quot;java.util.Date&quot;</span><span class="nt">&gt;&lt;/bean&gt;</span>
</code></pre></div>

<p>最后创建可运行的类，添加代码</p>
<div class="highlight"><pre><span></span><code>ClassPathXmlApplicationContext context
= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
Date date = (Date) context.getBean(&quot;date&quot;);
System.out.println(date);
context.close();
</code></pre></div>

<p>运行，即可查看到输出的日期。</p>
<p>以上做法雅秋该类存在无参构造方法！</p>
<h3>4.通过静态工厂方法创建并获取对象【不常用】</h3>
<p>某些类也许没有无参构造方法，但是，可能存在某个被<code>static</code>修饰的方法，并且该方法就返回当前类型的对象，例如<code>Calendar</code> 类中就存在：</p>
<div class="highlight"><pre><span></span><code>public static Calendar getInstance() {...}
</code></pre></div>

<p>以上<code>getInstance()</code>方法就是<code>Calendar</code>对象</p>
<h3>5.通过实例工厂创建并管理对象</h3>
<p>假设某个类并不满足以上2中方式创建对象，并且，存在另一个类，类中有某个方法可以创建对象，例如：</p>
<div class="highlight"><pre><span></span><code><span class="nv">public</span> <span class="nv">class</span> <span class="nv">UserDao</span> {
  <span class="nv">public</span> <span class="nv">UserDao</span><span class="ss">(</span><span class="nv">String</span> <span class="nv">s</span><span class="ss">)</span>{

  }
}

<span class="nv">public</span> <span class="nv">class</span> <span class="nv">UserDaoFactory</span> {
  <span class="nv">public</span> <span class="nv">UserDao</span> <span class="nv">newInstance</span><span class="ss">()</span> {
    <span class="k">return</span> <span class="nv">new</span> <span class="nv">UserDao</span><span class="ss">(</span><span class="nv">null</span><span class="ss">)</span><span class="c1">;</span>
  }
}
</code></pre></div>

<h3>6.由Spring管理对象的作用域 【仅了解】</h3>
<p>由Spring管理的对象，默认都是单例</p>
<blockquote>
<p>单例：在同一时间，某个类的对象一定只有一个！</p>
</blockquote>
<p>如果需要配置对象是否单例，可以：</p>
<!-- 属性scope: 配置类的对象的作用域，是否是单例，默认值是singleton， -->
<div class="highlight"><pre><span></span><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;user&quot;</span> <span class="na">class=</span><span class="s">&quot;cn.tedu.spring.User&quot;</span> <span class="na">scope=</span><span class="s">&quot;prototype&quot;</span><span class="nt">&gt;&lt;/bean&gt;</span>
</code></pre></div>

<p>如果是自行设计单例模式，可以是例如：</p>
<div class="highlight"><pre><span></span><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="p">();</span>

    <span class="kd">private</span> <span class="nf">User</span><span class="p">()</span> <span class="p">{</span>

    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">User</span> <span class="nf">getInstance</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">user</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>

<p>由于被获取的对象是使用了<code>static</code>修饰的，所以，单例的类的对象，都是静态的，也就是具有<strong>常驻内存</strong>的特点！则单例的对象的作用域就是整个程序加载这个列开始，知道程序结束！而非单例对象想的作用域就是普通的变量的作用域！</p>
<p>另外，单例模式还区分为<strong>懒汉式单例</strong>和<strong>饿汉式单例</strong>，如果是懒汉单例模式，只会在获取对象的前一刻才创建对象，如果是饿汉单例模式，则项目运行之初就已经创建了对象</p>
<p>默认情况下，由Spring管理的单例的对象都是<strong>饿汉式的</strong>！可以在Spring的配置文件中添加配置：</p>
<!-- lazy-init属性：是否懒汉式加载，取值可以是布尔值 -->
<p><bean id="user" class="cn.tedu.spring.User" scope="singleton" lazy-init="true" /></p>
<p><strong>注意：必须是单例模式的基础之上，再讨论是否加载的问题！</strong></p>
<p>关于懒汉式单例的实现代码:</p>
<div class="highlight"><pre><span></span><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">User</span> <span class="n">user</span><span class="p">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>

    <span class="kd">private</span> <span class="nf">User</span><span class="p">()</span> <span class="p">{};</span>

      <span class="kd">public</span> <span class="kd">static</span> <span class="n">User</span> <span class="nf">getInstance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="o">==</span> <span class="kc">null</span> <span class="p">){</span>
          <span class="n">sychronized</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="p">();</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">user</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>

<h3>7.由Spring管理的对象的生命周期【不常用】</h3>
<p>对象的生命周期就是从创建到销毁的历程</p>
<p>以<code>Servlet</code>为例，从创建到销毁的过程中，还会执行<code>init()</code>、<code>service()</code>、<code>destroy()</code>方法，其中，<code>init()</code> 方法是创建对象之后就会立即执行的除数方法，并且只会执行1次，而<code>service()</code>方法是每次收到请求后都会执行的方法，可能执行若干次、<code>destroy()</code>方法是销毁对象的前一刻执行的方法，也会执行1次！</p>
<p>在java EE中的<code>Servlet</code>组建是由容器（例如Tomcat）创建并管理的！作为程序员，必须知道哪些方法在什么时候被调用，才可以正确的重写这些方法，从而决定“什么时候应该做什么事情”！</p>
<p>当使用了Spring框架后，对象的管理权也是交给了框架的！为了保证在初始化时能定制所需要执行的任务，在销毁之前能释放资源等，也可以在类中生命对应的生命周期方法：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>

  <span class="kd">public</span> <span class="nf">User</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">super</span><span class="p">();</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;创建User对象！&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;User.onCreate()&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;User.onDestroy()&quot;</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div>

<p>在配置时，添加<code>init-method</code>和<code>destroy-method</code>属性的配置：</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;!--</span> <span class="n">init</span><span class="o">-</span><span class="n">method</span><span class="err">：生命周期方法的初始化方法的名称</span> <span class="o">--&gt;</span>
<span class="o">&lt;!--</span> <span class="n">destroy</span><span class="o">-</span><span class="n">method</span><span class="err">：生命周期方法的销毁方法的名称</span> <span class="o">--&gt;</span>
<span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;user&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;cn.tedu.spring.User&quot;</span>
    <span class="n">init</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;onCreate&quot;</span>
    <span class="n">destroy</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;onDestroy&quot;</span> <span class="o">/&gt;</span>
</code></pre></div>

<h3>8.Spring  Ioc</h3>
<h4>8.1 什么是Ioc</h4>
<p>Spring Ioc表示<strong>控制反转</strong>， 即在传统模式下，由程序员编写创建并管理对象，例如<code>User user = new User();</code>，当使用Spring框架之后，则将对象的创建、管理的权利交给了框架，则表示控制权给了框架，所以，称之为控制反转！</p>
<p>Spring框架是通过DI实现了IoC， DI（Dependency Injection）表示<strong>依赖注入</strong>。</p>
<h4>8.2 通过SET方法注入属性的值</h4>
<p>在对象的运行过程中，需要使用另一个对象，在编写代码时，在一个类中需要生命另一个类的对象，则表现出了依赖关系！例如在'UserLoginServlet'中声明了<code>UserDao</code>类型的属性，则称之为<strong>UserLoginServlet依赖于UserDao</strong>。</p>
<p>使用Spring框架，不仅可以管理某个类的对象,还可以创建对象的同时，为该类中声明属性进行复制，这种复制操作就称为<strong>注入</strong>。</p>
<p>假设存在：</p>
<div class="highlight"><pre><span></span><code>public class User {
  public String name;
}
</code></pre></div>

<p>希望通过Spring获取该<code>User</code>类的对象时，对象的<code>name</code>属性已经有值！首先，需要为<code>name</code>属性添加规范的SET方法:</p>
<div class="highlight"><pre><span></span><code>public void setName(String name) {
this.name = name;
}
</code></pre></div>

<p>然后在Spring的配置文件中，为配置<code>User</code>类的<code>Bean</code>节点添加子级的<code>property</code>节点：</p>
<div class="highlight"><pre><span></span><code><span class="c">&lt;!-- name属性：需要被注入值的属性名 --&gt;</span>
<span class="c">&lt;!-- value属性：需要注入的值 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;name&quot;</span> <span class="na">value=</span><span class="s">&quot;David&quot;</span><span class="nt">&gt;&lt;/property&gt;</span>
</code></pre></div>

<p>注意：在配置<code>property</code>节点时，<code>name</code>属性的值，其实，并不是类中的属性名，而是类中的方法名调整后的属性名，即将方法名称左侧的<code>set</code>去掉，即哪个字母改为小写后的名称！或者说，在Spring框架工作时，会根据配置的<code>property</code>中的<code>name</code>值，将首字母大写，并在左侧拼接上<code>set</code>，形成方法名，并调用该方法！</p>
<p>另外，可能还有一些类中的属性，并不是可以直接写出来的直接值，例如存在<code>UserLoginServlet</code>,其中有<code>UserDao</code>属性，如果需要为这个属性注入值，就需要使用<code>ref</code>属性引用另一个Bean：</p>
<div class="highlight"><pre><span></span><code>  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;userDao&quot;</span> <span class="na">class=</span><span class="s">&quot;cn.tedu.spring.UserDao&quot;</span><span class="nt">&gt;&lt;/bean&gt;</span>

  <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">&quot;userLoginServlet&quot;</span> <span class="na">class=</span><span class="s">&quot;cn.tedu.spring.UserLoginServlet&quot;</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- ref属性：引用另一个bean，该属性值是另一个bean的id --&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">&quot;userDao&quot;</span> <span class="na">ref=</span><span class="s">&quot;userDao&quot;</span><span class="nt">&gt;&lt;/property&gt;</span>
  <span class="nt">&lt;/bean&gt;</span>
</code></pre></div>

<p>在注入属性值是，<code>value</code>和<code>ref</code>都表示值，其中<code>value</code>用于可以直接写出来的值，例如字符串类型的值，数值、布尔值，而<code>ref</code>用于引用另一个Bean，当使用<code>ref</code>属性时，取值为另一个Bean节点的<code>id</code>。</p>
<h4>8.3 通过构造方法注入属性的值【不常用】</h4>
<p>假设存在：</p>
<div class="highlight"><pre><span></span><code>public class Person {
  public String from;
}
</code></pre></div>

<p>如果需要为以上<code>from</code>属性注入值，并且不实用SET方式来注入，则可以先添加带参数的构造方法，在构造方法中为<code>from</code> 赋值</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="n">String</span> <span class="n">from</span><span class="p">;</span>

  <span class="kd">public</span> <span class="nf">Person</span><span class="p">(</span><span class="n">String</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="na">from</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>以上使用的<code>&lt;constructor-arg&gt;</code>节点就是用于配置构造方法的参数的，如果构造方法中有多个参数，则需要多个该节点，每个节点1个参数！在该节点的<code>index</code>表示配置第几个参数，取值从0开始顺序编号！至于参数的值的配置，依然需要根据值的类型选择使用<code>value</code>或<code>ref</code>来配置！</p>
<h5>附1: 什么时候需要定义构造方法</h5>
<p>1.创建对象的同时，快速的赋值；
2.限制对象的创建过程，例如在单例模式的设计中，将构造方法声明为私有权限
3.强制要求传入某些数据
dasfhddjksjhdfkjshd结果好几个环境sasa</p>                </article>
            </aside><!-- /#featured -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>