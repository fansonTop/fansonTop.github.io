<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>java面向对象</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="对java面向对象的一些总结" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">fansonTop</a></h1>
                <nav><ul>
                    <li><a href="/category/ge-ren-ri-zhi.html">个人日志</a></li>
                    <li class="active"><a href="/category/java.html">java</a></li>
                    <li><a href="/category/mysql.html">mysql</a></li>
                    <li><a href="/category/suan-fa-ti-mu.html">算法题目</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2018/javamian-xiang-dui-xiang.html" rel="bookmark"
           title="Permalink to java面向对象">java面向对象</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-10-24T18:07:00+08:00">
                Published: 三 24 十月 2018
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/fanson.html">Fanson</a>
        </address>
<p>In <a href="/category/java.html">java</a>.</p>
<p>tags: <a href="/tag/java.html">java</a> <a href="/tag/oop.html">oop</a> </p>
</footer><!-- /.post-info -->      <hr>
<h3>java中的类和对象初识</h3>
<ol>
<li>
<p>对象的构成<br>
    1.1) 属性: 数据特性<br>
    1.2) 方法: 操作，行为<br>
    1.3) java中先有类型，后有对象    </p>
</li>
<li>
<p>在java中定义类<br>
    2.1) 在类中定义这个类的对象有哪些属性和方法<br>
    2.2) 声明属性<br>
    2.3) 声明方法  </p>
</li>
<li>
<p>在java中实例化类的对象 <strong>程序中操作的都是对象</strong><br>
    3.1) 一个类可以实例化无数个对象<br>
    3.2) 对象是程序操作的主体<br>
    3.3) 通过对象名加点（.）<br>
      &gt; 来访问对象的属性<br>
      &gt; 来调用对象的方法  </p>
<p>3.4) 实例化对象的格式:  </p>
<blockquote>
<p>&lt;类名&gt; &lt;对象名&gt; = new &lt;类名&gt;;</p>
</blockquote>
<p><code>java
        Student student = new Student();</code></p>
</li>
<li>
<p>对象属性的默认值<br>
    4.1) 对象的属性是有默认值的<br>
    4.2) 基本数据类型的默认值分别为0，0.0，false<br>
    4.3) 引用类型的数据的默认值为null</p>
</li>
</ol>
<hr>
<h3>方法重载</h3>
<ol>
<li>方法签名  </li>
<li>每个方法的定义都包含：<ul>
<li>修饰词</li>
<li>返回值类型</li>
<li>方法明</li>
<li>参数列表</li>
</ul>
</li>
<li>方法签名 = 方法名 + 参数列表</li>
<li>每个类中不允许方法签名完全相同的方法</li>
<li>
<p>方法名相同，参数列表不同是允许的</p>
</li>
<li>
<p>方法重载（方法超载，overload）<strong>方法重载在代码编译时确定，编译绑定</strong>  </p>
</li>
<li>在同一个类中，方法名相同，参数列表不同的多个方法</li>
<li>参数列表不同包含：<ul>
<li>数量</li>
<li>类型</li>
<li>顺序</li>
</ul>
</li>
<li>
<p>方法的修饰符和返回值类型，对方法重载无关紧要</p>
</li>
<li>
<p>方法重载的好处  </p>
</li>
<li>不需要记忆功能相似的方法名</li>
<li>系统中利用方法重载编写了很多内容，方便使用</li>
</ol>
<hr>
<h3>构造方法</h3>
<ol>
<li>定义  </li>
<li>在对象被实例化时运行的一个特殊方法</li>
<li>
<p>为什么需要特殊方法：</p>
<ul>
<li>在构造方法中可以给属性赋值</li>
</ul>
</li>
<li>
<p>构造方法编写  </p>
<p><code>java
      public &lt;类名&gt;() {方法体}</code></p>
<ul>
<li>构造方法没有返回值</li>
<li>构造方法名必须和类名相同</li>
<li>在实例化对象时，会自动运行构造方法</li>
</ul>
</li>
<li>
<p>构造方法注意事项  </p>
</li>
<li>如果一个类中没有编写构造方法，系统会自动给这个类分配一个默认的无参构造</li>
<li>如果一个类中编写了任意一个构造方法，那么系统就不会分配默认构造方法</li>
<li>构造方法可以重载</li>
<li>构造方法智能在实例话对象时调用，不能使用对象打点调用</li>
</ol>
<hr>
<h3>成员变量和局部变量</h3>
<ol>
<li>成员变量：<strong><em>类中定义的属性就是成员变量</em></strong>  </li>
<li>局部变量：<strong><em>方法中定义的变量和方法的形式参数就是局部变量</em></strong>  </li>
<li>区别  </li>
<li>作用域：<ul>
<li>成员变量：类中的所有方法均可使用（非静态）</li>
<li>局部变量：只有定义它的方法中可以使用  </li>
</ul>
</li>
<li>初始默认值不同：  <ul>
<li>成员变量：0/0.0/false/null  </li>
<li>局部变量：没有初始值  </li>
</ul>
</li>
<li>优先级不同  <ul>
<li>如果在一个方法中使用成员变量和局部变量  </li>
<li>并且变量名相同，优先使用局部变量  </li>
</ul>
</li>
</ol>
<hr>
<h3>this关键字</h3>
<ol>
<li>定义：方法中对象对自身的引用  </li>
<li>this.属性：能够区分成员变量和局部变量  </li>
<li>this.方法：调用当前类中的方法  </li>
<li>this&lt;参数&gt;：调用当前类的构造方法  </li>
<li>必须写在构造方法中  </li>
<li>必须写在方法中的第一行  </li>
</ol>
<hr>
<h3>数据类型分类</h3>
<ol>
<li>基本数据类型  </li>
</ol>
<blockquote>
<p>基本数据类型变量保存的值在内存的栈中</p>
</blockquote>
<ol>
<li>
<p>引用数据类型  </p>
<blockquote>
<p>String，数组，类<br>
引用数据类型变量保存在栈中的值，是它引用对象的引用值  </p>
</blockquote>
</li>
<li>
<p>引用数据类型的数组  </p>
<blockquote>
<p>int[] nums = new int[5]  基本数据类型的数组<br>
Dog[] dogs = new Dog[5]  引用数据类型的数组  </p>
</blockquote>
</li>
</ol>
<p>3.1) 引用数据类型数组元素的默认值为：null<br>
   3.2) 为引用数据类型数组元素赋值，需要赋值对象<br>
   3.3) 引用数据类型数组的元素，可以调用这个元素引用对象的属性和方法  </p>
<ol>
<li>
<p>空：null  </p>
<blockquote>
<p>null表示这个变量没有引用任何对象<br>
当一个变量引用null时，如果打点调用了任何属性或方法，都会引发空指针异常
   NullPointerException<br>
   解决方案：1.让原来的null的变量引用某个对象；2.判断为非空后再调用  </p>
</blockquote>
</li>
<li>
<p>引用类型数组也可以声明的同时赋值  </p>
</li>
</ol>
<p><code>java
       Dog[] dogs = {
           new Dog(...),
           new Dog(...),
           new Dog(...)
       };</code></p>
<ol>
<li>多维数组</li>
</ol>
<hr>
<h3>继承 <strong><em>继承/封装/多态</em></strong></h3>
<ol>
<li>定义：就是面向对象编程中一种代码复用的方式</li>
<li>继承的格式：</li>
</ol>
<p><code>java
       class A extends B {}</code></p>
<ol>
<li>注意事项：</li>
<li>java中继承都是单继承  </li>
<li>
<p>如果一个类没有继承任何父类，那么默认继承Object  </p>
</li>
<li>
<p>继承下构造方法的运行<br>
   4.1) 实例化子类对象时，会先运行父类的构造方法<br>
   4.2) 因为内存中子类对象中实际包含一个父类对象的引用，所有实例化子类对象前，要先实例化一个父类的对象<br>
   4.3) 子类中如果没有特殊编码，自动调用父类的无参构造，如果父类没有无参构造，会发生编译错误<br>
   4.4) 子类中可以选择调用父类的那个构造方法，使用super关键字  </p>
</li>
<li>
<p>super关键字<br>
   5.1) 定义：方法中对象对父类的引用<br>
   5.2) super的使用  </p>
<ul>
<li>super.&lt;属性&gt;：父类和子类有同名属性时，super调用父类的属性  </li>
<li>super.&lt;方法&gt;：父类和子类有同名方法时，super调用父类的方法  </li>
<li>super(参数列表)：调用父类的构造方法，必须卸载自类构造方法中的第一行  </li>
</ul>
<p><strong><em>java中如果在构造方法中没有编写哪个父类的构造，默认super()</em></strong></p>
</li>
<li>
<p>方法重写（方法覆盖，override）<br>
   6.1) 定义：在子类中编写一个和父类的某个方法一模一样的方法<br>
   6.2) 作用：使用父类引用可以调用到子类重写后的方法（向上造型后），实现父类调用子类方法<br>
   6.3) 规则：</p>
<ul>
<li>必须相同的地方：方法名，参数列表，如果返回值类型时void或是基本数据类型，必须一致  </li>
<li>可以不同的地方：返回值类型是引用数据类型时，子类的返回值类型可以时父类返回值类型的子类  </li>
<li>子类抛出的异常可以是父类抛出异常的子类  </li>
</ul>
</li>
<li>
<p>方法重载overload和方法重写override<br>
   7.1) 方法重载时编译期绑定，方法重写是运行期绑定<br>
   7.2) 方法重载中所有同一个类实际上是指同一个作用域  </p>
</li>
</ol>
<hr>
<h3>向上造型</h3>
<ol>
<li>定义：子类对象当作父类对象使用  </li>
</ol>
<p><code>java
       Pet p = new Dog();</code></p>
<ol>
<li>向上造型之后的优缺点<br>
   2.1) 缺点<br>
      &gt; 父类类型的引用，智能调用到父类中声明的成员，不能调用子类中声明的成员 </li>
</ol>
<p>2.2) 优点<br>
      &gt; 声明一个父类类型的数组，不同类型的子类对象可以放入同一个父类数组中管理  </p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>